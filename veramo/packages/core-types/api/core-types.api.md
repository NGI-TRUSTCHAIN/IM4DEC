## API Report File for "@veramo/core-types"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { DIDDocument } from 'did-resolver';
import { DIDResolutionOptions } from 'did-resolver';
import { DIDResolutionResult } from 'did-resolver';
import { KeyCapabilitySection } from 'did-resolver';
import { ServiceEndpoint } from 'did-resolver';
import { VerificationMethod } from 'did-resolver';

// @beta
export interface AuthorizedDIDContext extends IAgentContext<{}> {
    // (undocumented)
    authorizedDID?: string;
}

// @beta
export type CompactJWT = string;

// @beta
export type ContextType = string | Record<string, any> | (string | Record<string, any>)[];

// @public
export const CoreEvents: {
    error: string;
    warning: string;
};

// @beta
export interface CredentialPayload {
    // (undocumented)
    '@context'?: ContextType;
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    credentialStatus?: CredentialStatusReference;
    // (undocumented)
    credentialSubject?: CredentialSubject;
    // (undocumented)
    expirationDate?: DateType;
    // (undocumented)
    id?: string;
    // (undocumented)
    issuanceDate?: DateType;
    // (undocumented)
    issuer: IssuerType;
    // (undocumented)
    type?: string[];
}

// @beta
export type CredentialStatus = {
    revoked: boolean;
    [x: string]: any;
};

// @beta
export interface CredentialStatusGenerateArgs {
    [x: string]: any;
    type: string;
}

// @beta
export type CredentialStatusReference = {
    id: string;
    type: string;
    [x: string]: any;
};

// @beta
export interface CredentialStatusUpdateArgs {
    // Warning: (ae-forgotten-export) The symbol "CredentialStatusUpdateOptions" needs to be exported by the entry point index.d.ts
    options?: CredentialStatusUpdateOptions;
    vc: VerifiableCredential;
}

// @beta
export type CredentialSubject = {
    id?: string;
    [x: string]: any;
};

// @beta
export type DateType = string | Date;

// @beta
export type DIDDocComponent = VerificationMethod | ServiceEndpoint;

export { DIDDocument }

// @public
export type DIDDocumentSection = KeyCapabilitySection | 'verificationMethod' | 'publicKey' | 'service';

export { DIDResolutionOptions }

export { DIDResolutionResult }

// @beta
export interface FindArgs<TColumns> {
    order?: Order<TColumns>[];
    skip?: number;
    take?: number;
    where?: Where<TColumns>[];
}

// @beta
export type FindClaimsArgs = FindArgs<TClaimsColumns>;

// @beta
export type FindCredentialsArgs = FindArgs<TCredentialColumns>;

// @beta
export type FindIdentifiersArgs = FindArgs<TIdentifiersColumns>;

// @beta
export type FindMessagesArgs = FindArgs<TMessageColumns>;

// @beta
export type FindPresentationsArgs = FindArgs<TPresentationColumns>;

// @beta
export interface GetDIDComponentArgs {
    didDocument: DIDDocument;
    didUrl: string;
    section?: DIDDocumentSection;
}

// @public
export interface IAgent extends IAgentBase {
    // (undocumented)
    emit: (eventType: string, data: any) => Promise<void>;
    // (undocumented)
    execute: <A = any, R = any>(method: string, args: A) => Promise<R>;
}

// @public
export interface IAgentBase {
    // (undocumented)
    availableMethods: () => string[];
    // (undocumented)
    getSchema: () => IAgentPluginSchema;
}

// @public
export interface IAgentContext<T extends IPluginMethodMap> {
    agent: TAgent<T>;
}

// @public
export interface IAgentOptions {
    authorizedMethods?: string[];
    context?: Record<string, any>;
    overrides?: IPluginMethodMap;
    plugins?: IAgentPlugin[];
    schemaValidation?: boolean;
}

// @public
export interface IAgentPlugin extends IEventListener {
    // (undocumented)
    readonly methods?: IPluginMethodMap;
    // (undocumented)
    readonly schema?: IAgentPluginSchema;
}

// @public
export interface IAgentPluginSchema {
    // (undocumented)
    components: {
        schemas: any;
        methods: any;
    };
}

// @beta
export interface ICheckCredentialStatusArgs {
    credential: VerifiableCredential;
    didDocumentOverride?: DIDDocument;
}

// @public
export interface ICreateVerifiableCredentialArgs {
    [x: string]: any;
    // Warning: (ae-incompatible-release-tags) The symbol "credential" is marked as @public, but its signature references "CredentialPayload" which is marked as @beta
    credential: CredentialPayload;
    fetchRemoteContexts?: boolean;
    keyRef?: string;
    proofFormat: ProofFormat;
    removeOriginalFields?: boolean;
    // @deprecated
    save?: boolean;
}

// @public
export interface ICreateVerifiablePresentationArgs {
    [x: string]: any;
    challenge?: string;
    domain?: string;
    fetchRemoteContexts?: boolean;
    keyRef?: string;
    // Warning: (ae-incompatible-release-tags) The symbol "presentation" is marked as @public, but its signature references "PresentationPayload" which is marked as @beta
    presentation: PresentationPayload;
    proofFormat: ProofFormat;
    removeOriginalFields?: boolean;
    // @deprecated
    save?: boolean;
}

// @public
export interface ICredentialIssuer extends IPluginMethodMap {
    // Warning: (ae-incompatible-release-tags) The symbol "createVerifiableCredential" is marked as @public, but its signature references "IssuerAgentContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "createVerifiableCredential" is marked as @public, but its signature references "VerifiableCredential" which is marked as @beta
    createVerifiableCredential(args: ICreateVerifiableCredentialArgs, context: IssuerAgentContext): Promise<VerifiableCredential>;
    // Warning: (ae-incompatible-release-tags) The symbol "createVerifiablePresentation" is marked as @public, but its signature references "IssuerAgentContext" which is marked as @beta
    createVerifiablePresentation(args: ICreateVerifiablePresentationArgs, context: IssuerAgentContext): Promise<VerifiablePresentation>;
    // @beta
    listUsableProofFormats(identifier: IIdentifier, context: IAgentContext<{}>): Promise<Array<ProofFormat>>;
    // @internal
    matchKeyForJWT(key: IKey, context: IAgentContext<any>): Promise<boolean>;
}

// @public
export type ICredentialPlugin = ICredentialIssuer & ICredentialVerifier;

// @beta
export type ICredentialStatus = ICredentialStatusVerifier & ICredentialStatusManager;

// @beta
export interface ICredentialStatusManager extends IPluginMethodMap {
    credentialStatusGenerate(args: CredentialStatusGenerateArgs): Promise<CredentialStatusReference>;
    credentialStatusTypes(): Promise<Array<string>>;
    credentialStatusUpdate(args: CredentialStatusUpdateArgs): Promise<any>;
}

// @beta
export interface ICredentialStatusVerifier extends IPluginMethodMap {
    checkCredentialStatus(args: ICheckCredentialStatusArgs, context: IAgentContext<IResolver>): Promise<CredentialStatus>;
}

// @public
export interface ICredentialVerifier extends IPluginMethodMap {
    // Warning: (ae-incompatible-release-tags) The symbol "verifyCredential" is marked as @public, but its signature references "VerifierAgentContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "verifyCredential" is marked as @public, but its signature references "IVerifyResult" which is marked as @beta
    verifyCredential(args: IVerifyCredentialArgs, context: VerifierAgentContext): Promise<IVerifyResult>;
    // Warning: (ae-incompatible-release-tags) The symbol "verifyPresentation" is marked as @public, but its signature references "VerifierAgentContext" which is marked as @beta
    // Warning: (ae-incompatible-release-tags) The symbol "verifyPresentation" is marked as @public, but its signature references "IVerifyResult" which is marked as @beta
    verifyPresentation(args: IVerifyPresentationArgs, context: VerifierAgentContext): Promise<IVerifyResult>;
}

// @public
export interface IDataStore extends IPluginMethodMap {
    dataStoreDeleteMessage(args: IDataStoreDeleteMessageArgs): Promise<boolean>;
    dataStoreDeleteVerifiableCredential(args: IDataStoreDeleteVerifiableCredentialArgs): Promise<boolean>;
    dataStoreGetMessage(args: IDataStoreGetMessageArgs): Promise<IMessage>;
    // Warning: (ae-incompatible-release-tags) The symbol "dataStoreGetVerifiableCredential" is marked as @public, but its signature references "VerifiableCredential" which is marked as @beta
    dataStoreGetVerifiableCredential(args: IDataStoreGetVerifiableCredentialArgs): Promise<VerifiableCredential>;
    dataStoreGetVerifiablePresentation(args: IDataStoreGetVerifiablePresentationArgs): Promise<VerifiablePresentation>;
    dataStoreSaveMessage(args: IDataStoreSaveMessageArgs): Promise<string>;
    dataStoreSaveVerifiableCredential(args: IDataStoreSaveVerifiableCredentialArgs): Promise<string>;
    dataStoreSaveVerifiablePresentation(args: IDataStoreSaveVerifiablePresentationArgs): Promise<string>;
}

// @public
export interface IDataStoreDeleteMessageArgs {
    id: string;
}

// @public
export interface IDataStoreDeleteVerifiableCredentialArgs {
    hash: string;
}

// @public
export interface IDataStoreGetMessageArgs {
    id: string;
}

// @public
export interface IDataStoreGetVerifiableCredentialArgs {
    hash: string;
}

// @public
export interface IDataStoreGetVerifiablePresentationArgs {
    hash: string;
}

// @beta
export interface IDataStoreORM extends IPluginMethodMap {
    // @deprecated
    dataStoreORMGetIdentifiers(args: FindIdentifiersArgs, context: AuthorizedDIDContext): Promise<Array<PartialIdentifier>>;
    // @deprecated
    dataStoreORMGetIdentifiersCount(args: FindIdentifiersArgs, context: AuthorizedDIDContext): Promise<number>;
    dataStoreORMGetMessages(args: FindMessagesArgs, context: AuthorizedDIDContext): Promise<Array<IMessage>>;
    dataStoreORMGetMessagesCount(args: FindMessagesArgs, context: AuthorizedDIDContext): Promise<number>;
    dataStoreORMGetVerifiableCredentials(args: FindCredentialsArgs, context: AuthorizedDIDContext): Promise<Array<UniqueVerifiableCredential>>;
    dataStoreORMGetVerifiableCredentialsByClaims(args: FindClaimsArgs, context: AuthorizedDIDContext): Promise<Array<UniqueVerifiableCredential>>;
    dataStoreORMGetVerifiableCredentialsByClaimsCount(args: FindClaimsArgs, context: AuthorizedDIDContext): Promise<number>;
    dataStoreORMGetVerifiableCredentialsCount(args: FindCredentialsArgs, context: AuthorizedDIDContext): Promise<number>;
    dataStoreORMGetVerifiablePresentations(args: FindPresentationsArgs, context: AuthorizedDIDContext): Promise<Array<UniqueVerifiablePresentation>>;
    dataStoreORMGetVerifiablePresentationsCount(args: FindPresentationsArgs, context: AuthorizedDIDContext): Promise<number>;
}

// @public
export interface IDataStoreSaveMessageArgs {
    message: IMessage;
}

// @public
export interface IDataStoreSaveVerifiableCredentialArgs {
    // Warning: (ae-incompatible-release-tags) The symbol "verifiableCredential" is marked as @public, but its signature references "VerifiableCredential" which is marked as @beta
    verifiableCredential: VerifiableCredential;
}

// @public
export interface IDataStoreSaveVerifiablePresentationArgs {
    verifiablePresentation: VerifiablePresentation;
}

// @public
export interface IDIDManager extends IPluginMethodMap {
    didManagerAddKey(args: IDIDManagerAddKeyArgs, context: IAgentContext<IKeyManager>): Promise<any>;
    didManagerAddService(args: IDIDManagerAddServiceArgs, context: IAgentContext<IKeyManager>): Promise<any>;
    didManagerCreate(args: IDIDManagerCreateArgs, context: IAgentContext<IKeyManager>): Promise<IIdentifier>;
    didManagerDelete(args: IDIDManagerDeleteArgs, context: IAgentContext<IKeyManager>): Promise<boolean>;
    didManagerFind(args: IDIDManagerFindArgs): Promise<Array<IIdentifier>>;
    didManagerGet(args: IDIDManagerGetArgs): Promise<IIdentifier>;
    didManagerGetByAlias(args: IDIDManagerGetByAliasArgs): Promise<IIdentifier>;
    didManagerGetOrCreate(args: IDIDManagerGetOrCreateArgs, context: IAgentContext<IKeyManager>): Promise<IIdentifier>;
    didManagerGetProviders(): Promise<Array<string>>;
    didManagerImport(args: MinimalImportableIdentifier, context: IAgentContext<IKeyManager>): Promise<IIdentifier>;
    didManagerRemoveKey(args: IDIDManagerRemoveKeyArgs, context: IAgentContext<IKeyManager>): Promise<any>;
    didManagerRemoveService(args: IDIDManagerRemoveServiceArgs, context: IAgentContext<IKeyManager>): Promise<any>;
    didManagerSetAlias(args: IDIDManagerSetAliasArgs, context: IAgentContext<IKeyManager>): Promise<boolean>;
    // Warning: (ae-incompatible-release-tags) The symbol "didManagerUpdate" is marked as @public, but its signature references "IDIDManagerUpdateArgs" which is marked as @beta
    didManagerUpdate(args: IDIDManagerUpdateArgs, context: IAgentContext<IKeyManager>): Promise<IIdentifier>;
}

// @public
export interface IDIDManagerAddKeyArgs {
    did: string;
    key: IKey;
    options?: object;
}

// @public
export interface IDIDManagerAddServiceArgs {
    did: string;
    options?: object;
    service: IService;
}

// @public
export interface IDIDManagerCreateArgs {
    alias?: string;
    kms?: string;
    options?: object;
    provider?: string;
}

// @public
export interface IDIDManagerDeleteArgs {
    did: string;
}

// @public
export interface IDIDManagerFindArgs {
    alias?: string;
    provider?: string;
}

// @public
export interface IDIDManagerGetArgs {
    did: string;
}

// @public
export interface IDIDManagerGetByAliasArgs {
    alias: string;
    provider?: string;
}

// @public
export interface IDIDManagerGetOrCreateArgs {
    alias: string;
    kms?: string;
    options?: object;
    provider?: string;
}

// @public
export interface IDIDManagerRemoveKeyArgs {
    did: string;
    kid: string;
    options?: object;
}

// @public
export interface IDIDManagerRemoveServiceArgs {
    did: string;
    id: string;
    options?: object;
}

// @public
export interface IDIDManagerSetAliasArgs {
    alias: string;
    did: string;
}

// @beta
export interface IDIDManagerUpdateArgs {
    did: string;
    document: Partial<DIDDocument>;
    options?: {
        [x: string]: any;
    };
}

// @beta
export interface IError {
    errorCode?: string;
    message?: string;
}

// @public
export interface IEventListener {
    readonly eventTypes?: string[];
    onEvent?(event: {
        type: string;
        data: any;
    }, context: IAgentContext<{}>): Promise<void>;
}

// @public
export interface IHandleMessageArgs {
    metaData?: IMetaData[];
    raw: string;
    // @deprecated
    save?: boolean;
}

// @public
export interface IIdentifier {
    alias?: string;
    controllerKeyId?: string;
    did: string;
    keys: IKey[];
    provider: string;
    services: IService[];
}

// @public
export interface IKey {
    kid: string;
    kms: string;
    meta?: KeyMetadata | null;
    privateKeyHex?: string;
    publicKeyHex: string;
    type: TKeyType;
}

// @public
export interface IKeyManager extends IPluginMethodMap {
    keyManagerCreate(args: IKeyManagerCreateArgs): Promise<ManagedKeyInfo>;
    // @beta
    keyManagerDecryptJWE(args: IKeyManagerDecryptJWEArgs): Promise<string>;
    keyManagerDelete(args: IKeyManagerDeleteArgs): Promise<boolean>;
    // @beta
    keyManagerEncryptJWE(args: IKeyManagerEncryptJWEArgs): Promise<string>;
    keyManagerGet(args: IKeyManagerGetArgs): Promise<IKey>;
    keyManagerGetKeyManagementSystems(): Promise<Array<string>>;
    keyManagerImport(args: MinimalImportableKey): Promise<ManagedKeyInfo>;
    keyManagerSharedSecret(args: IKeyManagerSharedSecretArgs): Promise<string>;
    keyManagerSign(args: IKeyManagerSignArgs): Promise<string>;
    keyManagerSignEthTX(args: IKeyManagerSignEthTXArgs): Promise<string>;
    keyManagerSignJWT(args: IKeyManagerSignJWTArgs): Promise<string>;
}

// @public
export interface IKeyManagerCreateArgs {
    kms: string;
    meta?: KeyMetadata;
    type: TKeyType;
}

// @beta
export interface IKeyManagerDecryptJWEArgs {
    data: string;
    kid: string;
}

// @public
export interface IKeyManagerDeleteArgs {
    kid: string;
}

// @beta
export interface IKeyManagerEncryptJWEArgs {
    data: string;
    kid: string;
    to: Omit<IKey, 'kms'>;
}

// @public
export interface IKeyManagerGetArgs {
    kid: string;
}

// @public
export interface IKeyManagerSharedSecretArgs {
    publicKey: Pick<IKey, 'publicKeyHex' | 'type'>;
    secretKeyRef: string;
}

// @public
export interface IKeyManagerSignArgs {
    // (undocumented)
    [x: string]: any;
    algorithm?: string;
    data: string;
    encoding?: 'utf-8' | 'base16' | 'base64' | 'hex';
    keyRef: string;
}

// @public
export interface IKeyManagerSignEthTXArgs {
    kid: string;
    transaction: object;
}

// @public
export interface IKeyManagerSignJWTArgs {
    data: string | Uint8Array;
    kid: string;
}

// @public
export interface IMessage {
    attachments?: IMessageAttachment[];
    createdAt?: string;
    // Warning: (ae-incompatible-release-tags) The symbol "credentials" is marked as @public, but its signature references "VerifiableCredential" which is marked as @beta
    credentials?: VerifiableCredential[];
    data?: object | null;
    expiresAt?: string;
    from?: string;
    id: string;
    metaData?: IMetaData[] | null;
    presentations?: VerifiablePresentation[];
    raw?: string;
    replyTo?: string[];
    replyUrl?: string;
    returnRoute?: string;
    threadId?: string;
    to?: string;
    type: string;
}

// @public
export interface IMessageAttachment {
    // (undocumented)
    byte_count?: number;
    // Warning: (ae-incompatible-release-tags) The symbol "data" is marked as @public, but its signature references "IMessageAttachmentData" which is marked as @beta
    //
    // (undocumented)
    data: IMessageAttachmentData;
    // (undocumented)
    description?: string;
    // (undocumented)
    filename?: string;
    // (undocumented)
    format?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    lastmod_time?: string;
    // (undocumented)
    media_type?: string;
}

// @beta
export interface IMessageAttachmentData {
    // (undocumented)
    base64?: string;
    // (undocumented)
    hash?: string;
    // (undocumented)
    json?: any;
    // (undocumented)
    jws?: any;
    // (undocumented)
    links?: string[];
}

// @public
export interface IMessageHandler extends IPluginMethodMap {
    handleMessage(args: IHandleMessageArgs, context: IAgentContext<IDataStore>): Promise<IMessage>;
}

// @public
export interface IMetaData {
    type: string;
    value?: string;
}

// @public
export interface IPluginMethod {
    // (undocumented)
    (args: any, context: any): Promise<any>;
}

// @public
export interface IPluginMethodMap extends Record<string, IPluginMethod> {
}

// @public
export interface IResolver extends IPluginMethodMap {
    // @beta
    getDIDComponentById(args: GetDIDComponentArgs): Promise<DIDDocComponent>;
    resolveDid(args: ResolveDidArgs): Promise<DIDResolutionResult>;
}

// @public
export interface IService {
    description?: string;
    id: string;
    serviceEndpoint: IServiceEndpoint | IServiceEndpoint[];
    type: string;
}

// @public
export type IServiceEndpoint = string | Record<string, any>;

// @beta
export type IssuerAgentContext = IAgentContext<IResolver & Pick<IDIDManager, 'didManagerGet' | 'didManagerFind'> & Pick<IDataStore, 'dataStoreSaveVerifiablePresentation' | 'dataStoreSaveVerifiableCredential'> & Pick<IKeyManager, 'keyManagerGet' | 'keyManagerSign'>>;

// @beta
export type IssuerType = {
    id: string;
    [x: string]: any;
} | string;

// @public
export interface IVerifyCredentialArgs {
    [x: string]: any;
    // Warning: (ae-incompatible-release-tags) The symbol "credential" is marked as @public, but its signature references "W3CVerifiableCredential" which is marked as @beta
    credential: W3CVerifiableCredential;
    fetchRemoteContexts?: boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "policies" is marked as @public, but its signature references "VerificationPolicies" which is marked as @beta
    policies?: VerificationPolicies;
}

// @public
export interface IVerifyPresentationArgs {
    [x: string]: any;
    challenge?: string;
    domain?: string;
    fetchRemoteContexts?: boolean;
    // Warning: (ae-incompatible-release-tags) The symbol "policies" is marked as @public, but its signature references "VerificationPolicies" which is marked as @beta
    policies?: VerificationPolicies;
    presentation: W3CVerifiablePresentation;
}

// @beta
export interface IVerifyResult {
    [x: string]: any;
    error?: IError;
    verified: boolean;
}

// @public
export const KEY_ALG_MAPPING: Record<TKeyType, ReadonlyArray<TAlg>>;

// @public
export interface KeyMetadata {
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    algorithms?: TAlg[];
}

// @public
export type ManagedKeyInfo = Omit<IKey, 'privateKeyHex'>;

// @public
export type MinimalImportableIdentifier = {
    keys: Array<MinimalImportableKey>;
    services?: Array<IService>;
} & Omit<IIdentifier, 'keys' | 'services'>;

// @public
export type MinimalImportableKey = RequireOnly<IKey, 'privateKeyHex' | 'type' | 'kms'>;

// @beta
export interface Order<TColumns> {
    // (undocumented)
    column: TColumns;
    // (undocumented)
    direction: 'ASC' | 'DESC';
}

// @beta
export type PartialIdentifier = Partial<IIdentifier>;

// @beta
export interface PresentationPayload {
    // (undocumented)
    '@context'?: ContextType;
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    expirationDate?: DateType;
    // (undocumented)
    holder: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    issuanceDate?: DateType;
    // (undocumented)
    type?: string[];
    // (undocumented)
    verifiableCredential?: W3CVerifiableCredential[];
    // (undocumented)
    verifier?: string[];
}

// @public
export type ProofFormat = 'jwt' | 'lds' | 'EthereumEip712Signature2021';

// @beta
export interface ProofType {
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    type?: string;
}

// @public
export interface RemoveContext<T extends IPluginMethod> {
    // (undocumented)
    (args?: Parameters<T>[0] | undefined): ReturnType<T>;
}

// @public
export type RequireOnly<T, K extends keyof T> = Required<Pick<T, K>> & Partial<T>;

// @public
export interface ResolveDidArgs {
    didUrl: string;
    options?: DIDResolutionOptions;
}

// @public
export type TAgent<T extends IPluginMethodMap> = {
    [P in keyof T]: RemoveContext<T[P]>;
} & IAgent;

// @public
export type TAlg = 'ES256K' | 'ES256K-R' | 'ES256' | 'EdDSA' | 'ECDH' | 'ECDH-ES' | 'ECDH-1PU' | string;

// @beta
export type TClaimsColumns = 'context' | 'credentialType' | 'type' | 'value' | 'isObj' | 'id' | 'issuer' | 'subject' | 'expirationDate' | 'issuanceDate';

// @beta
export type TCredentialColumns = 'context' | 'type' | 'id' | 'issuer' | 'subject' | 'expirationDate' | 'issuanceDate' | 'hash';

// @beta @deprecated
export type TIdentifiersColumns = 'did' | 'alias' | 'provider';

// @public
export type TKeyType = 'Ed25519' | 'Secp256k1' | 'Secp256r1' | 'X25519' | 'Bls12381G1' | 'Bls12381G2';

// @beta
export type TMessageColumns = 'from' | 'to' | 'id' | 'createdAt' | 'expiresAt' | 'threadId' | 'type' | 'raw' | 'replyTo' | 'replyUrl';

// @beta
export type TPresentationColumns = 'context' | 'type' | 'id' | 'holder' | 'verifier' | 'expirationDate' | 'issuanceDate';

// @beta
export interface UniqueVerifiableCredential {
    // (undocumented)
    hash: string;
    // (undocumented)
    verifiableCredential: VerifiableCredential;
}

// @beta
export interface UniqueVerifiablePresentation {
    // (undocumented)
    hash: string;
    // (undocumented)
    verifiablePresentation: VerifiablePresentation;
}

// @beta
export interface UnsignedCredential {
    // (undocumented)
    '@context': ContextType;
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    credentialStatus?: CredentialStatusReference;
    // (undocumented)
    credentialSubject: CredentialSubject;
    // (undocumented)
    expirationDate?: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    issuanceDate: string;
    // (undocumented)
    issuer: IssuerType;
    // (undocumented)
    type?: string[] | string;
}

// @public
export interface UnsignedPresentation {
    // Warning: (ae-incompatible-release-tags) The symbol ""@context"" is marked as @public, but its signature references "ContextType" which is marked as @beta
    //
    // (undocumented)
    '@context': ContextType;
    // (undocumented)
    [x: string]: any;
    // (undocumented)
    expirationDate?: string;
    // (undocumented)
    holder: string;
    // (undocumented)
    id?: string;
    // (undocumented)
    issuanceDate?: string;
    // (undocumented)
    type?: string[] | string;
    // Warning: (ae-incompatible-release-tags) The symbol "verifiableCredential" is marked as @public, but its signature references "W3CVerifiableCredential" which is marked as @beta
    //
    // (undocumented)
    verifiableCredential?: W3CVerifiableCredential[];
    // (undocumented)
    verifier?: string[];
}

// @beta
export type VerifiableCredential = UnsignedCredential & {
    proof: ProofType;
};

// @public
export type VerifiablePresentation = UnsignedPresentation & {
    proof: ProofType;
};

// @beta
export interface VerificationPolicies {
    [x: string]: any;
    audience?: boolean;
    credentialStatus?: boolean;
    expirationDate?: boolean;
    issuanceDate?: boolean;
    now?: number;
}

// @beta
export type VerifierAgentContext = IAgentContext<IResolver & Pick<IDIDManager, 'didManagerGet' | 'didManagerFind'>>;

// @beta
export type W3CVerifiableCredential = VerifiableCredential | CompactJWT;

// Warning: (ae-incompatible-release-tags) The symbol "W3CVerifiablePresentation" is marked as @public, but its signature references "CompactJWT" which is marked as @beta
//
// @public
export type W3CVerifiablePresentation = VerifiablePresentation | CompactJWT;

// @beta
export interface Where<TColumns> {
    // (undocumented)
    column: TColumns;
    // (undocumented)
    not?: boolean;
    // (undocumented)
    op?: 'LessThan' | 'LessThanOrEqual' | 'MoreThan' | 'MoreThanOrEqual' | 'Equal' | 'Like' | 'Between' | 'In' | 'Any' | 'IsNull';
    // (undocumented)
    value?: string[];
}

// Warnings were encountered during analysis:
//
// src/types/vc-data-model.ts:145:63 - (ae-incompatible-release-tags) The symbol "proof" is marked as @public, but its signature references "ProofType" which is marked as @beta

```
